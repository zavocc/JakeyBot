from core.ai.assistants import Assistants
from core.ai.core import GenAIConfigDefaults
from core.ai.speech.tts import BaseTextToSpeech
from discord.ext import commands
from os import environ, path
import google.generativeai as genai
import discord
import random


class VoiceAI(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        
        # Initiate connection cache
        self.voice_conndata = BaseTextToSpeech()

        # Check for gemini API keys
        if environ.get("GOOGLE_AI_TOKEN") is None or environ.get("GOOGLE_AI_TOKEN") == "INSERT_API_KEY":
            raise Exception("GOOGLE_AI_TOKEN is not configured in the dev.env file. Please configure it and try again.")

        genai.configure(api_key=environ.get("GOOGLE_AI_TOKEN"))

    # Callback to stream audio
    async def reply_callback_from_model(self, sink: discord.sinks, text_channel: discord.TextChannel):
        # TODO: from ask command, implement chat history checks

        # TODO: Parse chat history

        # TODO: Context history

        # Initialize GenAIConfigDefaults
        genai_configs = GenAIConfigDefaults()

        # default system prompt - load assistants
        assistants_system_prompt = Assistants()

        # Model configuration - use pro experiment model
        model_to_use = genai.GenerativeModel(model_name="gemini-1.5-flash", safety_settings=genai_configs.safety_settings_config, generation_config=genai_configs.generation_config, system_instruction=assistants_system_prompt.jakey_system_prompt)
                
        for user_id, audio in sink.audio_data.items():
            if user_id == self.voice_conndata.guild_states.get(sink.vc.guild.id):
                file_path = path.join(f"{environ.get("TEMP_DIR", "temp")}", f"{user_id}.{sink.encoding}")
                with open(file_path, "wb") as f:
                    f.write(audio.file.read())

        # upload
        mmdal = genai.upload_file(file_path)

        # Answer the user's question
        chat_session = model_to_use.start_chat(history=[])

        # Send message
        answer = await chat_session.send_message_async([mmdal, "Answer from this audio"])

        # Embed the response if the response is more than 2000 characters
        # Check to see if this message is more than 2000 characters which embeds will be used for displaying the message
        if len(answer.text) > 4096:
            # Send the response as file
            response_file = f"{environ.get('TEMP_DIR', 'temp')}/response{random.randint(6000,7000)}.md"
            with open(response_file, "w+") as f:
                f.write(answer.text)
            await text_channel.send("⚠️ Response is too long. But, I saved your response into a markdown file", file=discord.File(response_file, "response.md"))
        elif len(answer.text) > 2000:
            embed = discord.Embed(
                # Truncate the title to (max 256 characters) if it exceeds beyond that since discord wouldn't allow it
                title=str("PPPPP")[0:100],
                description=str(answer.text),
                color=discord.Color.random()
            )
            embed.set_author(name="placeholder")
            embed.set_footer(text="Responses generated by AI may not give accurate results! Double check with facts!")
            await text_channel.send(embed=embed)
        else:
            await text_channel.send(answer.text)

        # Transcribe
        tts = BaseTextToSpeech()
        transdata = await tts.generate_speech(answer.text)

        # Play
        await sink.vc.play(discord.FFmpegPCMAudio(f"{transdata}", executable='ffmpeg'), wait_finish=True)
        await sink.vc.disconnect()

        # Remove self user id from guild states
        del self.voice_conndata.guild_states[sink.vc.guild.id]
        

    @commands.slash_command(
        contexts={discord.InteractionContextType.guild, discord.InteractionContextType.bot_dm},
        integration_types={discord.IntegrationType.guild_install, discord.IntegrationType.user_install}
    )
    async def call(self, ctx):
        voice = ctx.author.voice

        if not voice:
            await ctx.respond("You aren't in a voice channel!")

        # Lock user id
        if ctx.guild.id not in self.voice_conndata.guild_states:
            self.voice_conndata.guild_states.update({ctx.guild.id: ctx.author.id})
        elif self.voice_conndata.guild_states[ctx.guild.id] != ctx.author.id:
            await ctx.respond("I am currently recording for someone else. Please wait for them to finish.")

        try:
            vc = await voice.channel.connect() 
        except discord.errors.ClientException:
            await ctx.respond("I am already in a voice channel.")
            return
        self.voice_conndata.connections.update({ctx.guild.id: vc})

        vc.start_recording(
            discord.sinks.WaveSink(),
            self.reply_callback_from_model,
            ctx.channel 
        )
        await ctx.respond("If you're done, type `/stop` to stop recording.")

    @commands.slash_command(
        contexts={discord.InteractionContextType.guild, discord.InteractionContextType.bot_dm},
        integration_types={discord.IntegrationType.guild_install, discord.IntegrationType.user_install}
    )
    async def stop(self, ctx):
        if ctx.guild.id in self.voice_conndata.connections:  # Check if the guild is in the cache.
            vc = self.voice_conndata.connections[ctx.guild.id]
            vc.stop_recording()  # Stop recording, and call the callback (once_done).
            del self.voice_conndata.connections[ctx.guild.id]  # Remove the guild from the cache.
            await ctx.delete()  # And delete.
        else:
            await ctx.respond("I am currently not recording here.")

    async def cog_command_error(self, ctx: commands.Context, error: commands.CommandError):
        if isinstance(error, commands.NoPrivateMessage):
            await ctx.send("❌ Sorry, this feature is not supported in DMs. Please use this command inside the guild.")
        else:
            # Delete connection states
            if ctx.guild.id in self.voice_conndata.connections:
                del self.voice_conndata.connections[ctx.guild.id]

            if ctx.guild.id in self.voice_conndata.guild_states:
                del self.voice_conndata.guild_states[ctx.guild.id]
            raise error
        

def setup(bot):
    bot.add_cog(VoiceAI(bot))
