from core.ai.assistants import Assistants
from core.ai.core import GenAIConfigDefaults
from core.ai.speech.tts import BaseTextToSpeech
from discord.ext import commands
from os import environ, path
import google.generativeai as genai
import discord
import random


class VoiceAI(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.current_user = None
        self.connections = {}

        # Check for gemini API keys
        if environ.get("GOOGLE_AI_TOKEN") is None or environ.get("GOOGLE_AI_TOKEN") == "INSERT_API_KEY":
            raise Exception("GOOGLE_AI_TOKEN is not configured in the dev.env file. Please configure it and try again.")

        genai.configure(api_key=environ.get("GOOGLE_AI_TOKEN"))

    # Callback to stream audio
    async def reply_callback_from_model(self, sink: discord.sinks, text_channel: discord.TextChannel):
        # TODO: from ask command, implement chat history checks

        # TODO: Parse chat history

        # TODO: Context history

        # Initialize GenAIConfigDefaults
        genai_configs = GenAIConfigDefaults()

        # default system prompt - load assistants
        assistants_system_prompt = Assistants()

        # Model configuration - use pro experiment model
        model_to_use = genai.GenerativeModel(model_name="gemini-1.5-flash", safety_settings=genai_configs.safety_settings_config, generation_config=genai_configs.generation_config, system_instruction=assistants_system_prompt.jakey_system_prompt)

                
        for user_id, audio in sink.audio_data.items():
            if user_id == self.current_user:
                file_path = path.join(f"{environ.get("TEMP_DIR", "temp")}", f"{user_id}.{sink.encoding}")
                with open(file_path, "wb") as f:
                    f.write(audio.file.read())

        # upload
        mmdal = genai.upload_file(file_path)

        # Answer the user's question
        chat_session = model_to_use.start_chat(history=[])

        # Send message
        answer = await chat_session.send_message_async([mmdal, "Answer from this audio"])

        # Embed the response if the response is more than 2000 characters
        # Check to see if this message is more than 2000 characters which embeds will be used for displaying the message
        if len(answer.text) > 4096:
            # Send the response as file
            response_file = f"{environ.get('TEMP_DIR', 'temp')}/response{random.randint(6000,7000)}.md"
            with open(response_file, "w+") as f:
                f.write(answer.text)
            await text_channel.send("⚠️ Response is too long. But, I saved your response into a markdown file", file=discord.File(response_file, "response.md"))
        elif len(answer.text) > 2000:
            embed = discord.Embed(
                # Truncate the title to (max 256 characters) if it exceeds beyond that since discord wouldn't allow it
                title=str("PPPPP")[0:100],
                description=str(answer.text),
                color=discord.Color.random()
            )
            embed.set_author(name="placeholder")
            embed.set_footer(text="Responses generated by AI may not give accurate results! Double check with facts!")
            await text_channel.send(embed=embed)
        else:
            await text_channel.send(answer.text)

        # Transcribe
        tts = BaseTextToSpeech(answer.text)
        transdata = await tts.generate_speech()

        # Play
        await sink.vc.play(discord.FFmpegPCMAudio(f"{transdata}", executable='ffmpeg'), wait_finish=True)
        await sink.vc.disconnect()
        self.current_user = None


    @commands.slash_command(
        contexts={discord.InteractionContextType.guild, discord.InteractionContextType.bot_dm},
        integration_types={discord.IntegrationType.guild_install, discord.IntegrationType.user_install}
    )
    async def record(self, ctx):  # If you're using commands.Bot, this will also work.
        voice = ctx.author.voice

        if not voice:
            await ctx.respond("You aren't in a voice channel!")

        # Lock user id
        self.current_user = ctx.author.id

        vc = await voice.channel.connect()  # Connect to the voice channel the author is in.
        self.connections.update({ctx.guild.id: vc})  # Updating the cache with the guild and channel.

        vc.start_recording(
            discord.sinks.WaveSink(),
            self.reply_callback_from_model,
            ctx.channel 
        )
        await ctx.respond("If you're done, type `/stop` to stop recording.")

    @commands.slash_command(
        contexts={discord.InteractionContextType.guild, discord.InteractionContextType.bot_dm},
        integration_types={discord.IntegrationType.guild_install, discord.IntegrationType.user_install}
    )
    async def stop(self, ctx):
        if ctx.guild.id in self.connections:  # Check if the guild is in the cache.
            vc = self.connections[ctx.guild.id]
            vc.stop_recording()  # Stop recording, and call the callback (once_done).
            del self.connections[ctx.guild.id]  # Remove the guild from the cache.
            await ctx.delete()  # And delete.
        else:
            await ctx.respond("I am currently not recording here.")

def setup(bot):
    bot.add_cog(VoiceAI(bot))
